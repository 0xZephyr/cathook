/*
 * LagExploit.cpp
 *
 *  Created on: May 7, 2017
 *      Author: nullifiedcat
 */

#include "common.hpp"

namespace hacks
{
namespace shared
{
namespace lagexploit
{

CatVar toggle(CV_SWITCH, "se_toggle", "0", "Toggle sequence exploit");
CatVar shoot(CV_SWITCH, "se_shoot", "0",
             "Allows instant revving up or shooting two shots at once");

// SHOUTOUTS TO BLACKFIRE
CatVar doom(CV_SWITCH, "se_doom", "0",
            "Shoot 2+ shots at once, see Center string on activate.");
CatVar stickyspam(CV_SWITCH, "se_stickyspam", "0",
                  "Allows Spam of stickies simply by holding Mouse1.");
CatVar cloak(CV_SWITCH, "se_cloak", "0", "Instant decloak/cloak");
CatVar cap(CV_SWITCH, "se_cap", "0", "Auto instant cap");
CatVar cart(CV_SWITCH, "se_cart", "0", "Automatically farm points by touching "
                                       "the cart (only works on attacking "
                                       "team)");
CatVar instant_weapon_switch(CV_SWITCH, "se_switch", "0",
                             "Instant weapon switch");
CatVar key(CV_KEY, "se_key", "0", "Sequence exploit key");
CatVar master_switch(CV_SWITCH, "se_master", "1", "Enable sequence exploit",
                     "Master switch for the sequence exploit\nDisabling this "
                     "disables everything else that uses it");
CatVar value(CV_INT, "se_value", "900", "Sequence exploit value",
             "Value of user cmds to spam with");

CatCommand do_lagexploit("se_do", "Sequence exploit (for use in scripts)",
                         []() { AddExploitTicks(6); });
int exticks           = 0;
const model_t *point  = nullptr;
const model_t *point2 = nullptr;
const model_t *point3 = nullptr;
const model_t *point4 = nullptr;
const model_t *point5 = nullptr;
void AddExploitTicks(int ticks)
{
    exticks = std::max(ticks, exticks);
}

bool ExploitActive()
{
    if (toggle)
        return true;
    if (exticks > 0)
    {
        return true;
    }
    if (g_IInputSystem->IsButtonDown((ButtonCode_t)((int) key)))
    {
        return true;
    }
    return false;
}

static CatVar infinite_packs(CV_SWITCH, "infinite_packs", "0",
                             "Infinite Pickups",
                             "Activate sequence exploit when standing on "
                             "pickups while having not full HP/Ammo");
float servertime, nextattack;
void CreateMove()
{
    if (CE_BAD(LOCAL_E))
        return;
    if (!LOCAL_E->m_bAlivePlayer)
        return;
    if (exticks > 0)
        exticks--;

    if (!exticks)
    {
        // Infinite pickups (health and ammo)
        if (infinite_packs && CE_GOOD(LOCAL_E))
        {
            ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
            const Vector &max1 =
                p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            const Vector &min1 =
                p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            for (int i = 1; i < entity_cache::max; i++)
            {
                CachedEntity *e = ENTITY(i);
                // CE_BAD is used to prevent removeconding on empty spaces where
                // the item hasn't respawned Class check to ensure entity is
                // pickup item
                if (CE_BAD(e) || e->m_iClassID != CL_CLASS(CBaseAnimating))
                {
                    continue;
                }

                ICollideable *c = RAW_ENT(e)->GetCollideable();

                // Bounds check
                const Vector &max2 =
                    c->OBBMaxs() + e->m_vecOrigin + Vector(8, 8, 8);
                const Vector &min2 =
                    c->OBBMins() + e->m_vecOrigin - Vector(8, 8, 8);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    // logging::Info("Collision with %d", i);

                    // Lag for health
                    if (LOCAL_E->m_iHealth < LOCAL_E->m_iMaxHealth &&
                        (e->m_ItemType == ITEM_HEALTH_SMALL ||
                         e->m_ItemType == ITEM_HEALTH_MEDIUM ||
                         e->m_ItemType == ITEM_HEALTH_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                    // Lag for ammo / metal
                    // TODO: Alternative to - LOCAL_E->m_iAmmo <
                    // LOCAL_E->m_iMaxAmmo That is pseudocode but checking each
                    // weapon for ammo + engie for metal would be ideal
                    if (CE_INT(g_pLocalPlayer->weapon(), netvar.m_iAmmo) < 5 &&
                        (e->m_ItemType == ITEM_AMMO_SMALL ||
                         e->m_ItemType == ITEM_AMMO_MEDIUM ||
                         e->m_ItemType == ITEM_AMMO_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                }
            }
        }
    }

    // Previously was in GetUserCmd
    // Thanks Blackfire for helping me improve removecond!

    if (!g_pUserCmd)
        return;
    if (!g_pUserCmd->command_number)
        return;
    int amount = 0;
    if (cart)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!point2)
            {
                CachedEntity *pEnt = ENTITY(i);
                if (!CE_GOOD(pEnt))
                    continue;
                const model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/props_trainyard/bomb_cart.mdl", model_name))
                    point2 = model;
            }
            if (!point3)
            {
                CachedEntity *pEnt = ENTITY(i);
                if (!CE_GOOD(pEnt))
                    continue;
                const model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/props_2fort/trainwheel001.mdl", model_name))
                    point3 = model;
            }
            if (!point4)
            {
                CachedEntity *pEnt = ENTITY(i);
                if (!CE_GOOD(pEnt))
                    continue;
                const model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/custom/dirty_bomb_cart.mdl", model_name))
                    point4 = model;
            }
            if (!point5)
            {
                CachedEntity *pEnt = ENTITY(i);
                if (!CE_GOOD(pEnt))
                    continue;
                const model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/props_trainyard/bomb_cart_red.mdl",
                           model_name))
                    point5 = model;
            }
            if (!point2 && !point3 && !point4 && !point5)
                continue;
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == point2 || model == point3 || model == point4 ||
                model == point5)
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin + Vector(25, 25, 25);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin - Vector(25, 25, 25);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = 50;
                }
            }
        }
    }
    if (!master_switch)
        return;
    static bool bWasHolding = false;
    bool bIsHolding         = ((g_pUserCmd->buttons & IN_ATTACK) ||
                       (g_pUserCmd->buttons & IN_ATTACK2));

    if (cap)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!point)
            {
                CachedEntity *pEnt = ENTITY(i);
                if (!CE_GOOD(pEnt))
                    continue;
                const model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/props_gameplay/cap_point_base.mdl",
                           model_name))
                    point = model;
                else
                    continue;
            }
            if (!point)
                continue;
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == point)
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin + Vector(200, 200, 200);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin - Vector(200, 200, 200);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = (int) value;
                }
            }
        }
    }
    if (instant_weapon_switch && not HasCondition<TFCond_Cloaked>(LOCAL_E))
    {
        static int lastweapon = 0;
        if (lastweapon != g_pUserCmd->weaponselect)
            amount = 1 * 90;
        lastweapon = g_pUserCmd->weaponselect;
    }
    if (cloak && shoot)
    {

        if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
            HasCondition<TFCond_Cloaked>(LOCAL_E))
        {
            g_pUserCmd->buttons &= ~IN_ATTACK;
            g_pUserCmd->buttons |= IN_ATTACK2;
            amount = 2 * 90;
        }
        else if (CanShoot() && bIsHolding && !bWasHolding &&
                 g_pLocalPlayer->weapon()->m_iClassID != CL_CLASS(CTFFlareGun))
            amount = 1 * 90;
        else if (CanShoot() && bIsHolding && !bWasHolding &&
                 g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFFlareGun))
            amount = 2 * 90;
        else if (bWasHolding && !bIsHolding)
            amount = 1 * 90;

        bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                      (g_pUserCmd->buttons & IN_ATTACK2);
    }
    else if (!cloak)
    {
        if (shoot)
        {
            if (not g_pLocalPlayer->holding_sniper_rifle)
            {
                if (CanShoot() && bIsHolding && !bWasHolding &&
                    g_pLocalPlayer->weapon()->m_iClassID !=
                        CL_CLASS(CTFFlareGun))
                    amount = 1 * 90;
                else if (CanShoot() && bIsHolding && !bWasHolding &&
                         g_pLocalPlayer->weapon()->m_iClassID ==
                             CL_CLASS(CTFFlareGun))
                    amount = 2 * 90;
                else if (bWasHolding && !bIsHolding)
                    amount  = 1 * 90;
                bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                              (g_pUserCmd->buttons & IN_ATTACK2);
            }
            else
            {
                bIsHolding = (g_pUserCmd->buttons & IN_ATTACK);
                if (CanShoot() && bIsHolding && !bWasHolding)
                    amount = 1 * 90;
                else if (bWasHolding && !bIsHolding)
                    amount  = 1 * 90;
                bWasHolding = (g_pUserCmd->buttons & IN_ATTACK);
            }
        }
    }
    else if (!shoot)
    {
        if (cloak)
        {
            if ((g_pUserCmd->buttons & IN_ATTACK2) && !bWasHolding &&
                !HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                amount = 1 * 90;
            }

            if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
                HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                g_pUserCmd->buttons &= ~IN_ATTACK;
                g_pUserCmd->buttons |= IN_ATTACK2;
                amount = 2 * 90;
            }
            bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                          (g_pUserCmd->buttons & IN_ATTACK2);
        }
    }

    if (key.KeyDown() || exticks || toggle)
        amount = int(value);

    // Thanks Wheaties For help!
    if (stickyspam)
    {
        if (g_pLocalPlayer->weapon()->m_iClassID == (CL_CLASS(CTFCannon)) ||
            g_pLocalPlayer->weapon()->m_iClassID ==
                (CL_CLASS(CTFPipebombLauncher)))
        {
            static bool bSwitch = false;
            if ((g_pUserCmd->buttons & IN_ATTACK) && !bSwitch)
            {
                bSwitch = true;
            }
            else if (bSwitch)
            {
                amount = 1 * 50;
                g_pUserCmd->buttons &= ~IN_ATTACK;
                bSwitch = false;
            }
        }
    }
    // SHOUTOUTS TO BLACKFIRE
    if (doom)
    {
        static int i = 0;
        servertime =
            (float) (CE_INT(g_pLocalPlayer->entity, netvar.nTickBase)) *
            g_GlobalVars->interval_per_tick;
        static int lastwep = g_pLocalPlayer->weapon()->m_IDX;
        if (!nextattack || !i || g_pLocalPlayer->weapon()->m_IDX != lastwep)
            nextattack =
                CE_FLOAT(g_pLocalPlayer->weapon(), netvar.flNextPrimaryAttack);
        if (servertime - nextattack > 30.0f)
            nextattack = servertime - 30.0f;
        if (servertime - nextattack > 0.0f &&
            (g_pUserCmd->buttons & IN_ATTACK ||
             g_pUserCmd->buttons & IN_ATTACK2))
        {
            if (!i)
                i  = ((int) servertime - (int) nextattack);
            amount = i * 66;
            if (!CE_BYTE(g_pLocalPlayer->weapon(), netvar.m_iClip1))
            {
                g_pUserCmd->buttons &= ~IN_ATTACK;
                g_pUserCmd->buttons &= ~IN_ATTACK2;
            }
        }
        if (i)
            i--;
        lastwep = g_pLocalPlayer->weapon()->m_IDX;
    }
    if (!amount)
        return;
    /*g_pUserCmd->command_number += amount;
    g_pUserCmd->hasbeenpredicted = true;
    *(int *) ((unsigned) g_IBaseClientState + offsets::lastoutgoingcommand()) +=
        amount;*/
    INetChannel *ch = (INetChannel *) g_IEngine->GetNetChannelInfo();
    int &m_nOutSequenceNr =
        *(int *) ((unsigned) ch + offsets::m_nOutSequenceNr());
    m_nOutSequenceNr += amount;
    //*bSendPackets = true;
}
void Draw()
{
    if (doom && servertime - nextattack > 0.0f)
    {
        auto amount = (int) servertime - (int) nextattack;
        AddCenterString(format("Fireable amount: ", amount), colors::orange);
    }
}
}
}
}
