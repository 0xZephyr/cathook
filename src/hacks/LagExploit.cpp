/*
 * LagExploit.cpp
 *
 *  Created on: May 7, 2017
 *      Author: nullifiedcat
 */

#include "common.hpp"

namespace hacks
{
namespace shared
{
namespace lagexploit
{

CatVar toggle(CV_SWITCH, "se_toggle", "0", "Toggle sequence exploit");
CatVar shoot(CV_SWITCH, "se_shoot", "0",
             "Allows instant revving up or shooting two shots at once");
CatVar stickyspam(CV_SWITCH, "se_stickyspam", "0",
                  "Allows Spam of stickies simply by holding Mouse1.");
CatVar cloak(CV_SWITCH, "se_cloak", "0", "Instant decloak/cloak");
CatVar cap(CV_SWITCH, "se_cap", "0", "Auto instant cap");
CatVar instant_weapon_switch(CV_SWITCH, "se_switch", "0",
                             "Instant weapon switch");
CatVar key(CV_KEY, "se_key", "0", "Sequence exploit key");
CatVar master_switch(CV_SWITCH, "se_master", "1", "Enable sequence exploit",
                     "Master switch for the sequence exploit\nDisabling this "
                     "disables everything else that uses it");
CatVar value(CV_INT, "se_value", "900", "Sequence exploit value",
             "Value of user cmds to spam with");

CatCommand do_lagexploit("se_do", "Sequence exploit (for use in scripts)",
                         []() { AddExploitTicks(6); });
int exticks = 0;
model_t *point   = nullptr;
void AddExploitTicks(int ticks)
{
    exticks = std::max(ticks, exticks);
}

bool ExploitActive()
{
    if (toggle)
        return true;
    if (exticks > 0)
    {
        return true;
    }
    if (g_IInputSystem->IsButtonDown((ButtonCode_t)((int) key)))
    {
        return true;
    }
    return false;
}

static CatVar infinite_packs(CV_SWITCH, "infinite_packs", "0",
                             "Infinite Pickups",
                             "Activate sequence exploit when standing on "
                             "pickups while having not full HP/Ammo");
void CreateMove()
{
    if (CE_BAD(LOCAL_E))
        return;
    if (!LOCAL_E->m_bAlivePlayer)
        return;
    if (exticks > 0)
        exticks--;

    if (!exticks)
    {
        // Infinite pickups (health and ammo)
        if (infinite_packs && CE_GOOD(LOCAL_E))
        {
            ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
            const Vector &max1 =
                p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            const Vector &min1 =
                p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            for (int i = 1; i < entity_cache::max; i++)
            {
                CachedEntity *e = ENTITY(i);
                // CE_BAD is used to prevent removeconding on empty spaces where
                // the item hasn't respawned Class check to ensure entity is
                // pickup item
                if (CE_BAD(e) || e->m_iClassID != CL_CLASS(CBaseAnimating))
                {
                    continue;
                }

                ICollideable *c = RAW_ENT(e)->GetCollideable();

                // Bounds check
                const Vector &max2 =
                    c->OBBMaxs() + e->m_vecOrigin + Vector(8, 8, 8);
                const Vector &min2 =
                    c->OBBMins() + e->m_vecOrigin - Vector(8, 8, 8);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    // logging::Info("Collision with %d", i);

                    // Lag for health
                    if (LOCAL_E->m_iHealth < LOCAL_E->m_iMaxHealth &&
                        (e->m_ItemType == ITEM_HEALTH_SMALL ||
                         e->m_ItemType == ITEM_HEALTH_MEDIUM ||
                         e->m_ItemType == ITEM_HEALTH_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                    // Lag for ammo / metal
                    // TODO: Alternative to - LOCAL_E->m_iAmmo <
                    // LOCAL_E->m_iMaxAmmo That is pseudocode but checking each
                    // weapon for ammo + engie for metal would be ideal
                    if (CE_INT(g_pLocalPlayer->weapon(), netvar.m_iAmmo) < 5 &&
                        (e->m_ItemType == ITEM_AMMO_SMALL ||
                         e->m_ItemType == ITEM_AMMO_MEDIUM ||
                         e->m_ItemType == ITEM_AMMO_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                }
            }
        }
    }

    // Previously was in GetUserCmd
    // Thanks Blackfire for helping me improve removecond!

    if (!g_pUserCmd)
        return;
    if (!g_pUserCmd->command_number)
        return;
    if (!master_switch)
        return;
    int amount              = 0;
    static bool bWasHolding = false;
    bool bIsHolding         = ((g_pUserCmd->buttons & IN_ATTACK) ||
                       (g_pUserCmd->buttons & IN_ATTACK2));

    if (cap)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!point)
            {
                CachedEntity *pEnt   = ENTITY(i);
                model_t *model = RAW_ENT(pEnt)->GetModel();
                if (!model)
                    continue;
                const char *model_name = g_IModelInfo->GetModelName(model);
                if (strstr("models/props_gameplay/cap_point_base.mdl",
                           model_name))
                    point = model;
                else
                    continue;
            }

            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == point)
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin + Vector(44, 44, 44);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin - Vector(44, 44, 44);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = (int) value;
                }
            }
        }
    }
    if (instant_weapon_switch && not HasCondition<TFCond_Cloaked>(LOCAL_E))
    {
        static int lastweapon = 0;
        if (lastweapon != g_pUserCmd->weaponselect)
            amount = 1 * 90;
        lastweapon = g_pUserCmd->weaponselect;
    }
    if (cloak && shoot)
    {

        if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
            HasCondition<TFCond_Cloaked>(LOCAL_E) &&
            g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFKnife))
        {
            g_pUserCmd->buttons &= ~IN_ATTACK;
            g_pUserCmd->buttons |= IN_ATTACK2;
            amount = 2 * 90;
        }
        else if (CanShoot() && bIsHolding && !bWasHolding &&
                 g_pLocalPlayer->weapon()->m_iClassID != CL_CLASS(CTFFlareGun))
            amount = 1 * 90;
        else if (CanShoot() && bIsHolding && !bWasHolding &&
                 g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFFlareGun))
            amount = 2 * 90;
        else if (bWasHolding && !bIsHolding)
            amount = 1 * 90;

        bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                      (g_pUserCmd->buttons & IN_ATTACK2);
    }
    else if (!cloak)
    {
        if (shoot)
        {
            if (not g_pLocalPlayer->holding_sniper_rifle)
            {
                if (CanShoot() && bIsHolding && !bWasHolding &&
                    g_pLocalPlayer->weapon()->m_iClassID !=
                        CL_CLASS(CTFFlareGun))
                    amount = 1 * 90;
                else if (CanShoot() && bIsHolding && !bWasHolding &&
                         g_pLocalPlayer->weapon()->m_iClassID ==
                             CL_CLASS(CTFFlareGun))
                    amount = 2 * 90;
                else if (bWasHolding && !bIsHolding)
                    amount  = 1 * 90;
                bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                              (g_pUserCmd->buttons & IN_ATTACK2);
            }
            else
            {
                bIsHolding = (g_pUserCmd->buttons & IN_ATTACK);
                if (CanShoot() && bIsHolding && !bWasHolding)
                    amount = 1 * 90;
                else if (bWasHolding && !bIsHolding)
                    amount  = 1 * 90;
                bWasHolding = (g_pUserCmd->buttons & IN_ATTACK);
            }
        }
    }
    else if (!shoot)
    {
        if (cloak)
        {
            if (g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFKnife))
            {

                if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
                    HasCondition<TFCond_Cloaked>(LOCAL_E))
                {
                    g_pUserCmd->buttons &= ~IN_ATTACK;
                    g_pUserCmd->buttons |= IN_ATTACK2;
                    amount = 2 * 90;
                }
            }
            bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                          (g_pUserCmd->buttons & IN_ATTACK2);
        }
    }

    if (key.KeyDown() || exticks || toggle)
        amount = int(value);

    // Thanks Wheaties For help!
    if (stickyspam)
    {
        if (g_pLocalPlayer->weapon()->m_iClassID == (CL_CLASS(CTFCannon)) ||
            g_pLocalPlayer->weapon()->m_iClassID ==
                (CL_CLASS(CTFPipebombLauncher)))
        {
            static bool bSwitch = false;
            if ((g_pUserCmd->buttons & IN_ATTACK) && !bSwitch)
            {
                bSwitch = true;
            }
            else if (bSwitch)
            {
                amount = 1 * 50;
                g_pUserCmd->buttons &= ~IN_ATTACK;
                bSwitch = false;
            }
        }
    }
    if (!amount)
        return;

    /*g_pUserCmd->command_number += amount;
    g_pUserCmd->hasbeenpredicted = true;
    *(int *) ((unsigned) g_IBaseClientState + offsets::lastoutgoingcommand()) +=
        amount;*/
    INetChannel *ch = (INetChannel *) g_IEngine->GetNetChannelInfo();
    int &m_nOutSequenceNr =
        *(int *) ((unsigned) ch + offsets::m_nOutSequenceNr());
    m_nOutSequenceNr += amount;
}
}
}
}
